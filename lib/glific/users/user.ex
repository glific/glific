defmodule Glific.Users.User do
  @moduledoc false
  use Ecto.Schema
  use Pow.Ecto.Schema, user_id_field: :phone

  alias __MODULE__

  alias Glific.{
    AccessControl.Role,
    Contacts.Contact,
    Enums.UserRoles,
    Groups.Group,
    Partners.Organization,
    Settings.Language
  }

  alias Ecto.Changeset
  import Pow.Ecto.Schema.Changeset, only: [password_changeset: 3, current_password_changeset: 3]

  @type t() :: %__MODULE__{
          __meta__: Ecto.Schema.Metadata.t(),
          id: non_neg_integer | nil,
          name: String.t() | nil,
          phone: String.t() | nil,
          password_hash: String.t() | nil,
          fingerprint: String.t() | nil,
          contact_id: non_neg_integer | nil,
          contact: Contact.t() | Ecto.Association.NotLoaded.t() | nil,
          password: String.t() | nil,
          current_password: String.t() | nil,
          password_hash: String.t() | nil,
          language_id: non_neg_integer | nil,
          language: Language.t() | Ecto.Association.NotLoaded.t() | nil,
          organization_id: non_neg_integer | nil,
          organization: Organization.t() | Ecto.Association.NotLoaded.t() | nil,
          roles: [String.t() | atom()] | nil,
          groups: list() | Ecto.Association.NotLoaded.t() | nil,
          is_restricted: boolean(),
          inserted_at: :utc_datetime | nil,
          updated_at: :utc_datetime | nil,
          last_login_at: :utc_datetime | nil,
          last_login_from: String.t() | nil,
          upload_contacts: boolean() | false
        }

  @required_fields [:phone, :name, :password, :contact_id, :organization_id]
  @optional_fields [
    :name,
    :roles,
    :is_restricted,
    :last_login_from,
    :last_login_at,
    :language_id,
    :upload_contacts
  ]

  schema "users" do
    field :name, :string
    field :roles, {:array, UserRoles}, default: [:none]

    # is this user restricted to contacts only in groups that they are part of
    field :is_restricted, :boolean, default: false

    # we are lazy, so we use the fingerprint generated by pow as out unique token
    # to identify the same user from different browsers and/or machines
    field :fingerprint, :string, virtual: true

    field :upload_contacts, :boolean, default: false

    field :last_login_from, :string, default: nil
    field :last_login_at, :utc_datetime

    belongs_to :contact, Contact
    belongs_to :language, Language
    belongs_to :organization, Organization

    pow_user_fields()

    many_to_many :groups, Group, join_through: "users_groups", on_replace: :delete
    many_to_many :access_roles, Role, join_through: "user_roles", on_replace: :delete

    timestamps()
  end

  @doc """
  Overriding the changeset for PoW and switch phone and email. At some later point, we will
  send an SMS message to the user with a new code to change their password
  """
  @spec changeset(User.t(), map()) :: Ecto.Changeset.t()
  def changeset(user_or_changeset, attrs) do
    user_or_changeset
    |> Changeset.cast(attrs, @required_fields ++ @optional_fields)
    |> Changeset.validate_required(@required_fields)
    |> glific_phone_field_changeset(attrs, @pow_config)
    |> current_password_changeset(attrs, @pow_config)
    |> password_changeset(attrs, @pow_config)
    |> Changeset.unique_constraint(:contact_id)
  end

  @doc """
  Simple changeset for phone. We will add phone validation over a period of time
  """
  @spec glific_phone_field_changeset(Ecto.Schema.t() | Changeset.t(), map(), Pow.Config.t()) ::
          Changeset.t()
  def glific_phone_field_changeset(user_or_changeset, params, _config) do
    user_or_changeset
    |> Changeset.cast(params, [:phone])
    |> Changeset.update_change(:phone, &maybe_normalize_user_id_field_value/1)
    |> Changeset.validate_required([:phone])
    |> Changeset.unique_constraint([:phone, :organization_id])
  end

  @doc """
  Simple changeset for update name, roles and is_restricted
  """
  @spec update_fields_changeset(Ecto.Schema.t() | Changeset.t(), map()) ::
          Changeset.t()
  def update_fields_changeset(user_or_changeset, params) do
    user_or_changeset
    |> Changeset.cast(params, [
      :name,
      :roles,
      :password,
      :is_restricted,
      :last_login_at,
      :last_login_from,
      :language_id
    ])
    |> Changeset.validate_required([:name, :roles])
    |> password_changeset(params, @pow_config)
    |> Changeset.unique_constraint(:contact_id)
  end

  defp maybe_normalize_user_id_field_value(value) when is_binary(value),
    do: Pow.Ecto.Schema.normalize_user_id_field_value(value)
end
